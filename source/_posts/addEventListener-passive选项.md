---
title: addEventListener passive选项
date: 2018-02-07 14:58:55
tags:
---
摘自 http://blog.csdn.net/dj0379/article/details/52883315 

前文已经提过*addEventListener*有一个passive选项可以改善滚屏性能，本文将研究其中的原理。

当属性*passive*值为true的时候，Chrome称之为**passive event listener**。目前passive event listener支持mousewheel/touch相关事件。

## 为何需要passive event listener
Passive Event Listeners特性是为了提高页面的滑动流畅度而设计的，页面滑动流畅度的提升，直接影响到用户对这个页面最直观的感受。Facebook之前做了一项试验，他们将页面滑动的响应刷新率从60FPS降低到30FPS的时候，发现用户的参与度急速下降。

## Chrome浏览器相关概念
1. 绘制（Paint）：将绘制操作转换为图像（软件模式经过光栅化生成位图，硬件模式经过光栅化生成纹理）。在Chrome中，绘制分为两部分：绘制操作记录部分（main-thread side）和绘制实现部分（impl-side）。绘制记录部分将绘制操作记录到SKPicture，绘制实现部分将SKPicture进行光栅化转成图像。
2. 图层（Paint Layer）：在Chrome中，页面的绘制是分层绘制的，页面内容变化的时候，浏览器仅需要重新绘制内容变化的图层，没有变化的图层不需要重新绘制。
3. 合成（Composite）：将绘制好的图层图像混合在一起生产一张最终的图像显示在屏幕上。
4. 渲染（Render）：可以简单认为渲染等价于绘制+合成。
5. UI线程（UI Thread）：浏览器主线程，负责接收系统派发给浏览器窗口的事件、资源下载等。
6. 内核线程（Main/Render Thread）:Blink内核及V8引擎运行的线程，如DOM树构建、元素布局、绘制操作记录部分（main-thread side）、javascript执行逻辑等。
7. 合成线程（Compositor Thread）：负责图像的合成，如绘制实现部分（impl-side）、合成等。

## Chrome浏览器的线程化渲染框架
传统单线程渲染框架，内核线程包揽页面内容渲染的所有工作，如javascript执行，元素布局，图层绘制，图层图像合成等。
![](single.png)
这种框架有两个明显的问题：
1. 流水线的执行方式，后面的工作必须等待前面工作执行完成才能处理，无法将相互独立的工作并行处理；
2. 内核线程负责的工作太多且耗时，一旦遇上内核在执行耗时较长的工作，用户的输入事件将无法立即得到响应。

对于第一个问题，浏览器很难控制页面从内容变化到布局渲染整个过程的耗时，中间任何一项工作的执行都可能导致整体过程耗时变大，过大的耗时会导致页面内容的刷新率偏低，从而形成视觉上的卡顿。浏览器收到VSync中断信号通知的时候，意味着页面需要立即对内容进行渲染，如果内核线程可能还在执行业务javascript，页面渲染的内容无法立即开始，如果页面无法再下一个VSync中断信号到来之前完成对内容的渲染，则页面会出现丢帧，出现视觉体验的卡顿。

`
注：VSync信号中断的频率，一般跟设备屏幕的刷新率对齐，比如设备的刷新率为60FPS（Frame Per Second）,
那么大概16.67ms会触发一下VSync中断信号。Chrome浏览器和Android系统等都是通过VSync中断信号来通知页面启动内容的渲染。
`
为了优化第一个问题，Chrome浏览器对内核线程负责的工作进行拆分，通过多线程并发处理提高渲染效率减少丢帧，如内核线程仅负责DOM树构建、元素的布局、图层绘制记录部分（main-thread side）、javascript执行，图层绘制实现部分（impl-side）、图层图像合成则交给合成线程负责处理。这种多线程负责页面内容的渲染框架，在Chrome中称为线程化渲染框架（Threaded Compositor Architecture）。
![](compositor.png)
如上图所示，在Chrome的线程化渲染框架中，当内核线程完成第一帧的布局和记录绘制操作时，立即通知合成线程对第一帧进行渲染，然后内核线程就开始准备第2帧的布局和记录绘制操作。由此可以看出，内核线程在进行N+1帧的布局和记录绘制操作的同时，合成线程也在努力进行第N帧的渲染并交给屏幕展示。这里利用了CPU多核的特性进行并发处理，提高了页面的渲染效率。用户看到的页面内容是上一帧的内容快照，新的一帧还在处理中。

要优化第2个问题，对浏览器来说是非常困难的。只要输入事件要在内核线程执行逻辑，那么遇到内核线程在忙，必然无法立即得到响应。如用户的大部分输入事件都跟页面元素有关系，一旦页面元素注册了对应事件的监听器，监听器的逻辑代码（javascript）必须在内核线程中执行，这种输入事件经常无法立即得到响应。

有一些输入事件是可以不经过内核线程就能被快速处理的。在Chrome中，这类可以不经过内核线程就能快速处理的输入事件为手势输入事件（滑动、捏合），手势输入事件是由用户连续的普通输入事件组合产生，如连续的mousewheel/touchmove事件可能会生成GestureScrollBegin/GestrueScrollUpdate等手势事件。手势输入事件可以直接在已经渲染好的内容快照上操作，如滑动手势事件，直接对页面已经渲染好的内容快照进行滑动展示即可。由于线程化渲染框架的支持，手势输入事件可以不经过内核线程，直接有合成线程在内容快照上直接处理，所以即使此时内核线程在忙碌，用户的手势输入事件也可以马上得到响应。小demo可以验证Chrome的这个特性：如在一个有滚动条的页面内通过javascript执行一段死循环的代码（while-true），尝试上下滑动页面，你会发现此时页面仍能流畅地滑动。
`
注：感觉这段有问题。亲测在chrome中js加入死循环，页面卡死，页面并不会正常滚动。另外从MDN查询手势事件（GestureEvent），chrome并不支持手势事件。
`
![](gesture_event.png)
![](compatibility.png)
在事件处理函数中加入占用内核线程的代码，在没有passive选项的情况下，页面滚动会有卡顿，而在passive为true的时候，页面滚动并不会受事件处理函数复杂度的影响。如下图所示，passive为true的时候，处理器滚动与事件处理函数不是串行的。

![](dispatch.png)
